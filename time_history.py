"""
Module qtools.time_history
Version 0.8 (beta), 01/04/2019
Contains class TimeHistory
Author: Andreas H Nielsen
"""

import numpy as np
from scipy.integrate import cumtrapz
from math import pi, ceil
from qtools import config
from pathlib import Path

class TimeHistory:
	"""
	General class for time histories.
	
	Parameters
	----------
	time : Numpy 1D array
		Values of time for each corresponding entry in ``data``.
	data : Numpy 1D array
		Time history data values (note: the lengths of ``time`` and ``data`` must be the same).
	ordinate : string, optional
		The physical quantity contained in data.
		``{'d','v','a'}``, with 'd' = displacement, 'v' = velocity, 'a' = acceleration.
	
	Returns
	-------
	An instance of TimeHistory
	
	Attributes
	----------
	time : A 1D Numpy array with size :math:`N`.
		This array contains time points. The array is populated even when a fixed time step is specified.
	data : A 1D Numpy array with size :math:`N`.
		This array contains the ordinate values (i.e. acceleration, velocity or displacement).
	
	"""
	def __init__(self,time,data,ordinate='a'):
		
		if len(time) != len(data):
			raise IndexError('The lengths of time and data must be the same.')
		self.time = time
		self.data = data
		self.dt = time[1]-time[0]
		self.k = 0
		self.l = 0
		self.fNyq = 1/(2*self.dt)
		self.ordinate = ordinate
		self.label = '_nolegend_'
		self.Td = time[-1]-time[0]
		self.ndat = len(time)
	
		# Find the PGA
		if self.ordinate == 'a':
			self.pga = np.amax(np.fabs(self.data))

	def __call__(self,t):
		
		k = self.k
		if t <= self.time[0]:
			x = self.data[0]
			k = 0
		elif t >= self.time[-1]:
			x = self.data[-1]
			k = self.ndat-2
		else:
			t1 = self.time[k]
			t2 = self.time[k+1]
			while (t < t1 or t > t2):
				if t < t1:
					k -= 1
				elif t > t2:
					k += 1
				t1 = self.time[k]
				t2 = self.time[k+1]
			x1 = self.data[k]
			x2 = self.data[k+1]
			x = (x2-x1)/(t2-t1)*(t-t1)+x1
		self.k = k
		return x

	def __iter__(self):
		return self

	def __next__(self):
		if self.l < self.ndat:
			t = self.time[self.l]
			d = self.data[self.l]
			self.l += 1
		else:
			self.l = 0
			raise StopIteration
		return (t,d)
					
	def setdt(self,dt,b,fNyq):
		self.dt = dt
		self.dt_fixed = b
		self.fNyq = fNyq
	
	def setLabel(self,label):
		self.label = str(label)
		
	def writeth(self,filename,fmt='%8.4f, %8.4f'):
		a = np.transpose(np.array([self.time, self.data]))
		np.savetxt(filename,a,fmt=fmt)		 
		
	def integrate(self):
		
		if self.ordinate=='d':
			print('Warning: you are integrating a displacement time history.')
			self.ordinate = 'n/a'
		elif self.ordinate=='v':
			print('The time history has been integrated and now represents displacement.')
			self.ordinate = 'd'
		elif self.ordinate=='a':
			print('The time history has been integrated and now represents velocity.')
			self.ordinate = 'v'
		
		self.data = cumtrapz(self.data,self.time,initial=0)
		
	def zero_mean(self):
		
		self.data -= np.mean(self.data)


def harmonic(dt,f=1.0,Td=None,A=1.0,ordinate='a'):
	"""
	Create a sinusoidal time history.
	
	Parameters
	----------
	dt : float
		The time step.
	f : float, optional
		The frequency of the time history (in Hz).
	Td : float, optional
		The duration of the time history. The default value is Td = 100*dt.
	A : float, optional
		The amplitude of the time history.
	ordinate : string, optional
		The physical quantity of the data generated by this function.
		{'d','v','a'}``, with 'd' = displacement, 'v' = velocity, 'a' = acceleration.
	
	Implementation notes
	--------------------
	If Td/dt is not a whole number, then the duration will be increased such that Td = ceil(Td/dt)*dt.
	"""
	
	if Td is None:
		Td = 100*dt	
	n = ceil(Td/dt)
	Tdn = n*dt
	if Tdn != Td:
		print('WARNING: the duration has been increased to {:6.2f} seconds to accommodate {} timesteps'.format(Tdn,n))
	Td = Tdn
	w = 2*pi*f
	time = np.linspace(0.,Tdn,n)
	data = A*np.sin(w*time)
	th = TimeHistory(time,data,'a')
	th.setdt(dt,True,1/(2*dt))
	
	return th

def loadth(sfile,ordinate='a',dt=-1.0,factor=1.0,delimiter=None,comments='#',skiprows=0):
	"""
	Create a time history from a text file.
	
	Parameters
	----------
	sfile : string
		The path and name of the input file.
	ordinate : string, optional ``['d'|'v'|'a']``
		The physical quantity of the data imported from ``sfile``, with 'd' = displacement, 'v' = velocity, 'a' = acceleration.
	dt : float, optional
		The time step. A positive value forces a constant time step, in which case ``sfile`` must not contain any time values.
		A negative value (e.g. ``dt = -1.0``) signifies that the time step is specified in the input file.
	factor : float, optional
		This argument can be used to factor the input data.
	delimiter : string, optional
		The string used to separate values. The default is whitespace.
	comments : string or sequence of strings, optional
		The characters or list of characters used to indicate the start of a comment. None implies no comments. The default is '#'.
	skiprows : integer, optional
		Skip the first skiprows lines; default: 0.

	Implementation notes
	--------------------
	The Nyquist frequency is calculated as 1/(2*dt_min) where dt_min is the smallest time step in the input file
	(when the function is called with dt < 0) or simply equal to dt (when the function is called with dt > 0).
	"""

	if type(sfile)!=str:
		raise TypeError('The first argument to loadth() must be a string.')
	
	if dt > 0.0:
		dt_fixed = True
	else:
		dt_fixed = False
	
	if not dt_fixed:
		# Look for the time step definition in the input file
		fil = open(sfile,'r')
		for line in fil.readlines():
			if 'dt =' in line:
				met = line.partition('=')[2].lstrip()
				try:
					dt = float(met)
				except:
					pass
				else:
					dt_fixed = True
					break
		fil.close()

	# Now read the data from the specified file
	rawdata = np.loadtxt(sfile,delimiter=delimiter,comments=comments,skiprows=skiprows)
	ndat = np.size(rawdata)

	if dt_fixed:
		# Constant time step - the input file contains just ordinates
		fNyq = 1/(2*dt)
		time = np.linspace(0.0,dt*(ndat-1),num=ndat)
		data = np.reshape(rawdata,ndat)
	else:
		# The input file is defined as pairs of (time, data)
		if (np.size(rawdata[0])%2 != 0):
			# There is an odd number of entries in the first row.
			# This format is not supported.
			raise IndexError('In loadth(): when the time points are defined in the input file, an odd number of entries in the input file is not supported.')
		time = np.reshape(rawdata[:,0::2],np.size(rawdata[:,0::2]))
		data = np.reshape(rawdata[:,1::2],np.size(rawdata[:,1::2]))
		ndat //= 2
		# Find the highest frequency that can be represented by the time history and check for fixed time step
		dt0 = time[1]-time[0]
		ddt = 0.0; fNyq = 0.0
		for i in range(ndat-1):
			dt1 = time[i+1]-time[i]
			ddt = max(ddt,abs(dt1-dt0))
			fNyq = max(1/(2*dt1),fNyq)
		 # Check whether time step really is fixed
		if ddt < 1E-8:
			dt_fixed = True
			dt = dt0

	# Factor input data
	if factor != 1.0:
		data *= factor 
	
	# Create instance of TimeHistory
	th = TimeHistory(time,data,ordinate)
	th.setdt(dt,dt_fixed,fNyq)

	# Set label (removing the file path and the extension, if any)
	th.setLabel(Path(sfile).stem)
	
	# Output information
	config.vprint('Time history successfully read from file {}.'.format(sfile))
	if th.dt_fixed:
		config.vprint('Constant time step =',th.dt,'seconds will be used.')
	else:
		config.vprint('Variable time step will be used.')
	config.vprint('The duration is {:6.2f} seconds.'.format(th.Td))
	config.vprint('The estimated Nyquist frequency of the time history is {:6.2f} Hz.'.format(th.fNyq))
	config.vprint('There are',th.ndat,'points in the time history.')
	if ordinate == 'a':
		config.vprint('The PGA is {:6.2f} m/s**2.'.format(th.pga))
	config.vprint('------------------------------------------')
	
	return th

def arrayth(data,time=None,dt=-1.0,ordinate='a'):
	"""
	Create a time history from an array.
	
	Parameters
	----------
	data : Numpy 1D array
		The values of the time history.
	time : Numpy 1D array, optional
		Values of time for each corresponding entry in ``data`` (note: the lengths of ``time`` and ``data`` must be the same).
	dt : float, optional
		The time step. A positive value forces a constant time step, in which case ``time`` is overwritten with new values.
		A negative value (e.g. ``dt = -1.0``) signifies that the time values are specified in the ``time`` array.
	ordinate : string, optional
		The physical quantity of the data imported from ``sfile``.
		{'d','v','a'}``, with 'd' = displacement, 'v' = velocity, 'a' = acceleration.
	
	Implementation notes
	--------------------
	The Nyquist frequency is calculated as 1/(2*dt_min) where dt_min is the smallest time step in the input file
	(when the function is called with dt < 0) or simply equal to dt (when the function is called with dt > 0).
	"""

	# Check arguments
	if type(time) != np.ndarray and dt < 0:
		raise ValueError('Specify time or assign a positive value to dt.')
	if type(data) != np.ndarray:
		raise TypeError('data must be a Numpy array')
	if type(time) != np.ndarray and time != None:
		raise TypeError('In array(): time must be a Numpy array')
	if len(np.shape(data)) != 1:
		raise TypeError('In array(): data must be a 1D array.')
	if len(np.shape(time)) != 1  and type(time) == np.array:
		raise TypeError('In array(): time must be a 1D array.')
	
	ndat = len(data)
	if dt > 0.0:
		dt_fixed = True
		time = np.linspace(0.,(ndat-1)*dt,ndat)
		fNyq = 1/(2*dt)
	else:
		dt_fixed = False
		# Find the highest frequency that can be represented by the time history and check for fixed time step
		dt0 = time[1]-time[0]
		ddt = 0.0 ; fNyq = 0.0
		for i in range(ndat-1):
			dt1 = time[i+1]-time[i]
			ddt = max(ddt,abs(dt1-dt0))
			fNyq = max(1/(2*dt1),fNyq)
		 # Check whether time step really is fixed
		if ddt < 1E-8:
			dt_fixed = True
			dt = dt0
	
	th = TimeHistory(time,data,ordinate)
	
	th.setdt(dt,dt_fixed,fNyq)
	
	return th